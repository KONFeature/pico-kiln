<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PID Tuning</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>
<h1>PID Auto-Tuning</h1>
<p><button onclick="location.href='/'">Back</button></p>

<h2>Select Mode</h2>
<div id="modeSelector">
<label><input type="radio" name="mode" value="SAFE" onclick="selectMode('SAFE')"> SAFE (30-45 min, 100°C)</label><br>
<label><input type="radio" name="mode" value="STANDARD" onclick="selectMode('STANDARD')" checked> STANDARD (1-2 hrs, 150°C)</label><br>
<label><input type="radio" name="mode" value="THOROUGH" onclick="selectMode('THOROUGH')"> THOROUGH (3-4 hrs, 200°C)</label><br>
<label><input type="radio" name="mode" value="HIGH_TEMP" onclick="selectMode('HIGH_TEMP')"> HIGH_TEMP (3-4 hrs, 500°C)</label>
</div>

<p>Max Temp Override (°C): <input type="number" id="maxTemp" size="5" min="50" max="500"></p>

<h3>Safety Checklist</h3>
<ul>
<li>Kiln is cool (room temperature)</li>
<li>No profile running</li>
<li>Do not interrupt tuning</li>
</ul>

<div id="controlButtons">
<button id="startBtn" onclick="startTuning()">Start Tuning</button>
<button id="stopBtn" onclick="stopTuning()" style="display:none">Stop Tuning</button>
</div>

<h2>Status</h2>
<div id="progressSection" style="display:none">
<p><b>Mode:</b> <span id="tuningMode">--</span> | <b>Step:</b> <span id="stepIndicator">--</span></p>
<p id="stepProgress"></p>
<p>Progress: <span id="progressPercent">0</span>%</p>
</div>

<table>
<tr><td>Current Temp:</td><td><b id="currentTemp">--</b></td></tr>
<tr><td>Max Temp:</td><td><b id="maxTempDisplay">--</b></td></tr>
<tr><td>SSR Output:</td><td><b id="ssrOutput">--</b></td></tr>
<tr><td>Elapsed:</td><td><b id="elapsedTime">--</b></td></tr>
</table>

<div id="stepDetails" style="display:none">
<p><b>Step:</b> <span id="stepName">--</span> | <b>Time:</b> <span id="stepTime">--</span></p>
<p><b>Plateau:</b> <span id="plateauStatus">--</span></p>
</div>

<div id="errorDisplay" style="display:none;color:red">
<p><b>Error:</b> <span id="errorMessage"></span></p>
</div>
<div id="completeDisplay" style="display:none;color:green">
<p><b>Complete!</b> Data saved to CSV. Use analyze_tuning.py to calculate PID.</p>
</div>

<script>
let pollingInterval = null;
let selectedMode = 'STANDARD';

function selectMode(mode) {
  selectedMode = mode;
}

function startTuning() {
  const maxTempInput = document.getElementById('maxTemp').value;
  const maxTemp = maxTempInput ? parseFloat(maxTempInput) : null;

  if (maxTemp !== null && (isNaN(maxTemp) || maxTemp < 50 || maxTemp > 500)) {
    alert('Max temperature must be between 50-500°C or left blank');
    return;
  }

  const duration = {'SAFE': '30-45 min', 'STANDARD': '1-2 hours', 'THOROUGH': '3-4 hours', 'HIGH_TEMP': '3-4 hours'}[selectedMode];
  if (!confirm('Start ' + selectedMode + ' tuning?\\n\\nDuration: ' + duration + '\\nKiln must be cool.')) return;

  setTuningActive(true);
  document.getElementById('completeDisplay').style.display = 'none';
  document.getElementById('errorDisplay').style.display = 'none';
  document.getElementById('progressSection').style.display = 'block';

  fetch('/api/tuning/start', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({mode: selectedMode, max_temp: maxTemp})
  })
  .then(r => r.json())
  .then(d => {
    if (d.success) {
      startPolling();
    } else {
      alert('Error: ' + d.error);
      setTuningActive(false);
    }
  })
  .catch(e => {
    alert('Failed: ' + e);
    setTuningActive(false);
  });
}

function stopTuning() {
  if (!confirm('Stop tuning? Data will be lost.')) return;
  fetch('/api/tuning/stop', {method: 'POST'})
  .then(r => r.json())
  .then(d => {
    stopPolling();
    setTuningActive(false);
  })
  .catch(e => alert('Failed: ' + e));
}

function startPolling() {
  pollingInterval = setInterval(updateStatus, 2000);
  updateStatus();
}

function stopPolling() {
  if (pollingInterval) {
    clearInterval(pollingInterval);
    pollingInterval = null;
  }
}

function setTuningActive(active) {
  document.getElementById('startBtn').style.display = active ? 'none' : 'inline';
  document.getElementById('startBtn').disabled = active;
  document.getElementById('stopBtn').style.display = active ? 'inline' : 'none';
  document.getElementById('maxTemp').disabled = active;
  document.querySelectorAll('input[name="mode"]').forEach(function(input) {
    input.disabled = active;
  });
}

function updateStatus() {
  fetch('/api/tuning/status')
  .then(r => r.json())
  .then(d => {
    const isTuning = d.state === 'TUNING';
    setTuningActive(isTuning);

    if (!isTuning) {
      stopPolling();
      return;
    }

    const t = d.tuning;
    if (!t) {
      console.error('State is TUNING but tuning data is missing');
      document.getElementById('progressSection').innerHTML = '<div style="color:red;padding:20px">Error: Tuning data unavailable. Please stop and restart tuning.</div>';
      return;
    }

    document.getElementById('progressSection').style.display = 'block';
    document.getElementById('tuningMode').textContent = t.mode;
    document.getElementById('stepIndicator').textContent = (t.step_index + 1) + '/' + (t.total_steps + 1);

    // Build step progress
    const container = document.getElementById('stepProgress');
    container.innerHTML = '';
    const currentIndex = t.stage === 'cooling' ? t.total_steps : t.step_index;

    for (let i = 0; i < t.total_steps; i++) {
      const step = document.createElement('span');
      step.textContent = (i + 1) + ' ';
      if (i < currentIndex) step.innerHTML = '<b>' + (i + 1) + '</b> ';
      else if (i === currentIndex) step.innerHTML = '<u>' + (i + 1) + '</u> ';
      container.appendChild(step);
    }

    const coolStep = document.createElement('span');
    if (t.stage === 'cooling') coolStep.innerHTML = '<u>Cool</u>';
    else if (t.stage === 'complete') coolStep.innerHTML = '<b>Cool</b>';
    else coolStep.textContent = 'Cool';
    container.appendChild(coolStep);

    // Progress percentage
    let progress = 0;
    if (t.stage === 'cooling') {
      progress = 90;
    } else if (t.total_steps > 0) {
      const stepProgress = (t.step_index / t.total_steps) * 90;
      const withinStepProgress = t.step_duration ? (t.step_elapsed / t.step_duration) * (90 / t.total_steps) : 0;
      progress = stepProgress + withinStepProgress;
    }
    document.getElementById('progressPercent').textContent = Math.min(Math.round(progress), 100);

    // Status grid
    document.getElementById('currentTemp').textContent = d.current_temp.toFixed(1) + '°C';
    document.getElementById('maxTempDisplay').textContent = t.max_temp + '°C';
    document.getElementById('ssrOutput').textContent = d.ssr_output.toFixed(0) + '%';
    document.getElementById('elapsedTime').textContent = formatTime(t.elapsed);

    // Step details
    if (t.stage === 'heating') {
      document.getElementById('stepDetails').style.display = 'block';
      document.getElementById('stepName').textContent = t.step_name;
      document.getElementById('stepTime').textContent = formatTime(t.step_elapsed) + ' / ' + formatTime(t.step_duration);

      if (t.plateau) {
        document.getElementById('plateauStatus').textContent = 'Detecting (' + formatTime(t.plateau.elapsed) + ' / ' + formatTime(t.plateau.required) + ')';
      } else {
        document.getElementById('plateauStatus').textContent = 'Monitoring';
      }
    } else {
      document.getElementById('stepDetails').style.display = 'none';
    }

    // Completion/error
    if (t.stage === 'complete') {
      stopPolling();
      document.getElementById('completeDisplay').style.display = 'block';
      document.getElementById('progressSection').style.display = 'none';
      setTuningActive(false);
    } else if (t.stage === 'error') {
      stopPolling();
      document.getElementById('errorMessage').textContent = t.error;
      document.getElementById('errorDisplay').style.display = 'block';
      document.getElementById('progressSection').style.display = 'none';
      setTuningActive(false);
    }
  })
  .catch(e => console.error('Status error:', e));
}

function formatTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60);
  return m + ':' + (s < 10 ? '0' : '') + s;
}

// Check status on page load
updateStatus();
</script>
</body>
</html>
